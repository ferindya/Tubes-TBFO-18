FORHEAD -> for VAR in range ( VRANGE ) | for VAR in VAL | for VAR, VAR in VAL;
VRANGE -> VAL , VAL | VAL | VAL , VAL , VAL;
FUNCTION -> VAR ( VFUNCTION ) | FUNCTION ( FUNCTION ) | VAR ( );
VFUNCTION -> VFUNCTION , VFUNCTION | VAL | VAR = VAL;
FOR -> FORHEAD : SLOOP;
BOOLEAN -> True | False;
NONE -> None;
OPLOGIC -> and | or;
OPIDENTITY -> is | is not | in;
IMPORT -> from VAR import VIMPORT | from VAR import* | import VIMPORT | import VAR as VAR | from VAR import VAR as VAR;
VIMPORT -> VAR | VIMPORT , VIMPORT;
VWITH -> VAL | VAL , VAL | VAL , VAL , VAL | VAL , VAL , VAL , VAL | VAL , VAL , VAL , VAL , VAL | VAL , VAL , VAL , VAL , VAL , VAL | VAL , VAL , VAL , VAL , VAL , VAL , VAL | VAL , VAL , VAL , VAL , VAL , VAL , VAL , VAL;
WITH -> with open ( VWITH ) : S | with open ( VWITH ) as VAR : S;
WHILE -> while COMP : SLOOP;
COMP -> BOOLEAN | VAR | ( COMP ) | COMP OPLOGIC COMP | COMPOPRT OPCOMP COMPOPRT | COMPOPRT OPCOMP = COMPOPRT | COMPOPRT = = COMPOPRT | not VAR | not COMP | COMPOPRT OPIDENTITY COMPOPRT;
COMPOPRT -> COMPOPRT OPARITH COMPOPRT | COMPOPRT OPCOMP COMPOPRT | COMPOPRT OPCOMP = COMPOPRT | VAL | VAL OPARITH VAL | VAL * * VAL | VAL / / VAL | VAL > > VAL | VAL < < VAL | VAL OPCOMP VAL | VAL OPCOMP = VAL | ( COMPOPRT );
RAISE -> raise VAR ( STRING ) | raise ( STRING ) | raise ( );
BREAK -> break;
PASS -> pass;
CONTINUE -> continue;
VIF -> if COMP : S | if COMP : IFRET;
VELIF -> elif COMP : S | elif COMP : IFRET;
VELSE -> else : S | else : IFRET;
IF -> VIF | VIF ELIF | VIF ELSE | VIF RAISE | VIF RAISE ELIF | VIF RAISE ELSE | VIF PASS | VIF PASS ELIF | VIF PASS ELSE;
ELIF -> VELIF | VELIF ELIF | VELIF ELSE | VELIF RAISE | VELIF RAISE ELIF | VELIF RAISE ELSE | VELIF PASS | VELIF PASS ELIF | VELIF PASS ELSE;
ELSE -> VELSE | VELSE RAISE | VELSE pass;
VIFL -> if COMP : SLOOP | if COMP : IFRET;
VELIFL -> elif COMP : SLOOP | elif COMP : IFRET;
VELSEL -> else : SLOOP | else : IFRET;
IFLOOP -> VIFL | VIFL ELIFLOOP | VIFL ELSELOOP | VIFL RAISE | VIFL RAISE ELIFLOOP | VIFL RAISE ELSELOOP | VIFL PASS | VIFL PASS ELIFLOOP | VIFL PASS ELSELOOP | VIFL CONTINUE | VIFL CONTINUE ELIFLOOP | VIFL CONTINUE ELSELOOP | VIFL BREAK | VIFL BREAK ELIFLOOP | VIFL BREAK ELSELOOP;
ELIFLOOP -> VELIFL | VELIFL ELIFLOOP | VELIFL ELSELOOP | VELIFL RAISE | VELIFL RAISE ELIFLOOP | VELIFL RAISE ELSELOOP | VELIFL PASS | VELIFL PASS ELIFLOOP | VELIFL PASS ELSELOOP | VELIFL CONTINUE | VELIFL CONTINUE ELIFLOOP | VELIFL CONTINUE ELSELOOP | VELIFL BREAK | VELIFL BREAK ELIFLOOP | VELIFL BREAK ELSELOOP;
ELSELOOP -> VELSEL | VELSEL RAISE | VELSEL PASS | VELSEL CONTINUE | VELSEL BREAK | else : BREAK;
IFRET -> S return VRET | return VRET | S return | return;
DEF -> DEFV : S return VRET | DEFV : S return | DEFV : S;
DEFV -> def VAR ( VDEF ) | def VAR ( );
VDEF -> VDEF , VDEF | variable | VAR = VAL;
VRET -> VRET , VRET | variable | COMP | ( VRET ) | NUMBER | BOOLEAN | STRING | NONE;
ICLASS -> VAR | ICLASS , ICLASS | VAR = VAR;
CLASS -> class VAR : S | class VAR ( ICLASS ) : S;
VCLASS -> VCLASS . VCLASS | VCLASS . FUNCTION | variable | FUNCTION
